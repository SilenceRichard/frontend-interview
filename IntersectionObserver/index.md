# Intersection Observer

## 1. API 简介与应用场景

- 作用：监听目标元素是否进入视口区域
- 核心能力：在元素“出现”或“消失”时触发回调
- 应用场景：
  - 图片懒加载
  - 视频播放控制
  - 无限滚动加载
  - 曝光埋点与动画触发
- 对比 scroll 监听方式：更高性能、无需手动计算位置

---

## 2. 基础用法示例

- 创建 `IntersectionObserver` 实例，传入回调函数
- 使用 `.observe()` 开始监听目标元素
- 回调函数中的 `entry.isIntersecting` 表示是否可见
- 无需监听 scroll，无需计算 offsetTop

---

## 3. 配置项解析

### root

- 默认为 `null`，表示视口
- 也可指定为容器元素，监听“局部滚动区域”

### threshold

- 控制“可见比例”触发点，范围 0~1 或数组
- 常见值：
  - `0`：刚进入视口就触发
  - `0.5`：进入一半才触发
  - `1`：完全进入才触发

### rootMargin

- 类似 CSS 的 `margin`，用于扩大或缩小观察边界
- 可用于“提前触发”加载逻辑，如 `'0px 0px -50px 0px'`

---

## 4. 图片懒加载

- 初始不设置 `src`，而将真实地址放入 `data-src`
- 进入视口时将 `data-src` 赋值给 `src`
- 加载完后调用 `.unobserve()` 解除监听
- 优势：
  - 节省网络请求
  - 提高页面加载性能
- 使用 `data-*` 自定义属性机制安全可靠

---

## 5. 无限滚动加载

- 页面底部插入一个不可见的“哨兵元素”
- 当哨兵进入视口，触发数据加载
- 不监听 scroll，不计算滚动高度
- 每次加载后刷新或重置哨兵节点

---

## 6. 视频播放控制

- 给视频元素添加观察逻辑
- 元素可见时调用 `video.play()`
- 元素离开视口时调用 `video.pause()`
- 设置合适的 `threshold`（如 0.5）提升触发精度
- 使用 `.catch()` 处理自动播放失败的异常

---

## 7. 与虚拟列表的对比

| 对比项             | Intersection Observer          | 虚拟列表（Virtual List）       |
|------------------|-------------------------------|-------------------------------|
| 作用重点           | 判断元素是否出现在视口内         | 控制渲染内容，仅保留可见节点     |
| 使用目的           | 触发行为（懒加载/埋点等）         | 提升长列表渲染性能               |
| 是否可组合使用       | ✅ 可以结合使用                    | ✅ 可结合 IO 做内容懒加载         |

- IO 是“视觉触发器”
- 虚拟列表是“性能渲染器”
- 两者职责不同，但可以协同工作

---

## 8. 总结与实践建议

- Intersection Observer 简化了“元素可见性”判断
- 性能好，写法简洁，兼容主流浏览器
- 推荐在以下场景使用：
  - 图片、视频懒加载
  - 滚动加载内容
  - 动画曝光控制
- 可结合虚拟列表进一步优化大规模内容渲染
- 建议动手练习 3 个 demo 场景，加深理解

---
